from collections import deque

# Convert tuple to a printable 3x3 board
def print_board(state):
    for i in range(0, 9, 3):
        print(state[i], state[i+1], state[i+2])
    print()

# Moves for the blank tile (0)
moves = {
    0: [1, 3],
    1: [0, 2, 4],
    2: [1, 5],
    3: [0, 4, 6],
    4: [1, 3, 5, 7],
    5: [2, 4, 8],
    6: [3, 7],
    7: [4, 6, 8],
    8: [5, 7]
}

# Perform DFS
def dfs(start, goal, max_depth=20):
    stack = [(start, [], 0)]  # (state, path, depth)
    visited = set()

    while stack:
        state, path, depth = stack.pop()

        if state == goal:
            return path + [state]

        if depth >= max_depth:
            continue

        visited.add(state)
        zero_pos = state.index(0)

        for move_pos in moves[zero_pos]:
            new_state = list(state)
            new_state[zero_pos], new_state[move_pos] = new_state[move_pos], new_state[zero_pos]
            new_state = tuple(new_state)

            if new_state not in visited:
                stack.append((new_state, path + [state], depth + 1))

    return None


# -------------------------------
# RUNNING THE PROGRAM
# -------------------------------

start = (1, 2, 3,
         4, 0, 6,
         7, 5, 8)

goal = (1, 2, 3,
        4, 5, 6,
        7, 8, 0)

print("Start State:")
print_board(start)

result = dfs(start, goal, max_depth=30)

if result:
    print("Solution Found! Steps:")
    for step_num, board in enumerate(result):
        print(f"Step {step_num}:")
        print_board(board)
else:
    print("No solution found within depth limit.")
